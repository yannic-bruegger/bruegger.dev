---
interface Props {
  text: string
  fontSize?: number
  cellSize?: number
}

const { text, fontSize = 80, cellSize = 8 } = Astro.props
---

<div
  class="ascii-text-container"
  data-text={text}
  data-font-size={fontSize}
  data-cell-size={cellSize}
>
  <canvas class="ascii-canvas block"></canvas>
  <span class="sr-only">{text}</span>
</div>

<script>
  class AsciiWaveText {
    private container: HTMLElement;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private text: string;
    private fontSize: number;
    private cellSize: number;
    private chars = ' ░▒▓█';
    private grid: { char: string; baseX: number; baseY: number; brightness: number }[] = [];
    private mouseX = 0.5;
    private mouseY = 0.5;
    private time = 0;
    private animationId: number = 0;
    private cols = 0;
    private rows = 0;

    constructor(container: HTMLElement) {
      this.container = container;
      this.canvas = container.querySelector('.ascii-canvas')!;
      this.ctx = this.canvas.getContext('2d')!;
      this.text = container.dataset.text || '';
      this.fontSize = parseInt(container.dataset.fontSize || '72');
      this.cellSize = parseInt(container.dataset.cellSize || '10');

      this.init();
      this.bindEvents();
      this.animate();
    }

    private init() {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d')!;

      tempCtx.font = `900 ${this.fontSize}px system-ui, -apple-system, sans-serif`;
      const metrics = tempCtx.measureText(this.text);
      const textWidth = metrics.width;
      const textHeight = this.fontSize;

      tempCanvas.width = textWidth;
      tempCanvas.height = textHeight;

      tempCtx.fillStyle = '#000';
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.font = `900 ${this.fontSize}px system-ui, -apple-system, sans-serif`;
      tempCtx.fillStyle = '#fff';
      tempCtx.textBaseline = 'top';
      tempCtx.textAlign = 'left';
      tempCtx.fillText(this.text, 0, 0);

      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

      this.cols = Math.ceil(tempCanvas.width / this.cellSize);
      this.rows = Math.ceil(tempCanvas.height / this.cellSize);

      this.canvas.width = this.cols * this.cellSize;
      this.canvas.height = this.rows * this.cellSize;

      this.grid = [];

      for (let y = 0; y < this.rows; y++) {
        for (let x = 0; x < this.cols; x++) {
          const px = x * this.cellSize;
          const py = y * this.cellSize;

          let totalBrightness = 0;
          let samples = 0;

          for (let sy = 0; sy < this.cellSize; sy++) {
            for (let sx = 0; sx < this.cellSize; sx++) {
              const imgX = px + sx;
              const imgY = py + sy;
              if (imgX < imageData.width && imgY < imageData.height) {
                const i = (imgY * imageData.width + imgX) * 4;
                totalBrightness += imageData.data[i];
                samples++;
              }
            }
          }

          const brightness = samples > 0 ? totalBrightness / samples : 0;

          if (brightness > 50) {
            const charIndex = Math.floor((brightness / 255) * (this.chars.length - 1));
            this.grid.push({
              char: this.chars[charIndex],
              baseX: px,
              baseY: py,
              brightness
            });
          }
        }
      }
    }

    private render() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.font = `${this.cellSize * 1.2}px "IBM Plex Mono", "SF Mono", Consolas, monospace`;
      this.ctx.textBaseline = 'top';

      for (const cell of this.grid) {
        const normX = cell.baseX / this.canvas.width;
        const normY = cell.baseY / this.canvas.height;

        // Wave distortion (subtle)
        const waveX = Math.sin(this.time * 1.5 + normY * 4) * 1;
        const waveY = Math.cos(this.time * 1.5 + normX * 4) * 1;

        // Mouse influence
        const dx = normX - this.mouseX;
        const dy = normY - this.mouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const mouseInfluence = Math.max(0, 1 - dist * 2);

        const offsetX = waveX + dx * mouseInfluence * 15;
        const offsetY = waveY + dy * mouseInfluence * 15;

        const x = cell.baseX + offsetX;
        const y = cell.baseY + offsetY;

        // Color gradient from violet to cyan based on position + mouse
        const hue = 260 + normX * 40 + mouseInfluence * 30;
        const saturation = 70 + mouseInfluence * 30;
        const lightness = 65 + mouseInfluence * 20;

        this.ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        this.ctx.fillText(cell.char, x, y);
      }
    }

    private animate = () => {
      this.time += 0.016;
      this.render();
      this.animationId = requestAnimationFrame(this.animate);
    }

    private bindEvents() {
      document.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouseX = (e.clientX - rect.left) / rect.width;
        this.mouseY = (e.clientY - rect.top) / rect.height;
      });

      const observer = new ResizeObserver(() => {
        this.init();
      });
      observer.observe(this.container);
    }
  }

  document.querySelectorAll('.ascii-text-container').forEach((container) => {
    new AsciiWaveText(container as HTMLElement);
  });
</script>
