---
interface Props {
  text: string
  class?: string
}

const { text, class: className } = Astro.props
---

<div class="ascii-container relative" data-text={text}>
  <canvas class="ascii-canvas"></canvas>
  <h1 class:list={["ascii-fallback sr-only", className]}>{text}</h1>
</div>

<style>
  .ascii-container {
    font-family: monospace;
    line-height: 1;
  }

  .ascii-canvas {
    display: block;
  }
</style>

<script>
  class AsciiText {
    private container: HTMLElement;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private text: string;
    private chars = ' .:-=+*#%@';
    private fontSize = 64;
    private cellSize = 8;
    private mouseX = -1000;
    private mouseY = -1000;

    constructor(container: HTMLElement) {
      this.container = container;
      this.canvas = container.querySelector('.ascii-canvas')!;
      this.ctx = this.canvas.getContext('2d')!;
      this.text = container.dataset.text || '';

      this.init();
      this.bindEvents();
    }

    private init() {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d')!;

      tempCtx.font = `bold ${this.fontSize}px system-ui, sans-serif`;
      const metrics = tempCtx.measureText(this.text);
      const textWidth = metrics.width;
      const textHeight = this.fontSize;

      tempCanvas.width = textWidth + 20;
      tempCanvas.height = textHeight + 20;

      tempCtx.fillStyle = '#000';
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.font = `bold ${this.fontSize}px system-ui, sans-serif`;
      tempCtx.fillStyle = '#fff';
      tempCtx.textBaseline = 'top';
      tempCtx.fillText(this.text, 10, 10);

      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

      const cols = Math.ceil(tempCanvas.width / this.cellSize);
      const rows = Math.ceil(tempCanvas.height / this.cellSize);

      this.canvas.width = cols * this.cellSize;
      this.canvas.height = rows * this.cellSize;

      this.render(imageData, cols, rows);
    }

    private render(imageData: ImageData, cols: number, rows: number) {
      this.ctx.fillStyle = '#09090b';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.font = `${this.cellSize * 1.2}px monospace`;
      this.ctx.textBaseline = 'top';

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const px = x * this.cellSize;
          const py = y * this.cellSize;

          let totalBrightness = 0;
          let samples = 0;

          for (let sy = 0; sy < this.cellSize; sy++) {
            for (let sx = 0; sx < this.cellSize; sx++) {
              const imgX = px + sx;
              const imgY = py + sy;
              if (imgX < imageData.width && imgY < imageData.height) {
                const i = (imgY * imageData.width + imgX) * 4;
                totalBrightness += imageData.data[i];
                samples++;
              }
            }
          }

          const avgBrightness = samples > 0 ? totalBrightness / samples : 0;

          if (avgBrightness > 10) {
            const charIndex = Math.floor((avgBrightness / 255) * (this.chars.length - 1));
            const char = this.chars[charIndex];

            const distX = px - this.mouseX;
            const distY = py - this.mouseY;
            const dist = Math.sqrt(distX * distX + distY * distY);
            const maxDist = 100;

            let r = 161, g = 161, b = 170; // zinc-400

            if (dist < maxDist) {
              const factor = 1 - (dist / maxDist);
              r = Math.floor(161 + (139 - 161) * factor); // toward violet
              g = Math.floor(161 + (92 - 161) * factor);
              b = Math.floor(170 + (246 - 170) * factor);
            }

            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.fillText(char, px, py);
          }
        }
      }
    }

    private bindEvents() {
      let imageData: ImageData;
      let cols: number, rows: number;

      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d')!;
      tempCtx.font = `bold ${this.fontSize}px system-ui, sans-serif`;
      const textWidth = tempCtx.measureText(this.text).width;
      tempCanvas.width = textWidth + 20;
      tempCanvas.height = this.fontSize + 20;
      tempCtx.fillStyle = '#000';
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.font = `bold ${this.fontSize}px system-ui, sans-serif`;
      tempCtx.fillStyle = '#fff';
      tempCtx.textBaseline = 'top';
      tempCtx.fillText(this.text, 10, 10);
      imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      cols = Math.ceil(tempCanvas.width / this.cellSize);
      rows = Math.ceil(tempCanvas.height / this.cellSize);

      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouseX = e.clientX - rect.left;
        this.mouseY = e.clientY - rect.top;
        this.render(imageData, cols, rows);
      });

      this.canvas.addEventListener('mouseleave', () => {
        this.mouseX = -1000;
        this.mouseY = -1000;
        this.render(imageData, cols, rows);
      });
    }
  }

  document.querySelectorAll('.ascii-container').forEach((container) => {
    new AsciiText(container as HTMLElement);
  });
</script>
